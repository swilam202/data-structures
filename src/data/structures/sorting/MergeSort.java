/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package data.structures.sorting;

/**
 *
 * @author Swilam
 */

/*
    بيشتغل بانك بتمسك الليستة وتفضل تقسمها اجزاء
    لحد اما يوصل ل ليستة فيها عنصرين بس
    وبعد كده يرتبها ويرجع باستخدام ال 
    Recursion
    ويرتب الليستة الي اتقسمت لعصرين يرتبها
    ويرجع برضو يرتب الليستة الي اتقسمت بعد اما يرتب النصين الي اتقسموا
    
    space complexity: O(n) 
    time complexity: O(n log(n)) 
    divide and conquer algorithm
*/


public class MergeSort {
    
    // دي نقطة البداية هنا 
    //و ممكن تسال ليه بديله نهاية وبداية الدالة مش ممكن اديله الليستة وهو جوة يحسب كل حاجة
    //لا لاننا هنعمل 
    // Recursion
    // علي اجزاء معينة من الدالة
      public static void merge_sort(int[] arr,int start, int end){
          
          //هنا ال 
          //base case
          // هنفضل نعمل 
          // recursion
          // لحد ما نوصل ل ليستة من عنصرين
          // وهنا نوقف ال
          // recursion
        if(start < end){
            
            //هنا بنحسب نص الحتة الي هنقسمها
            int middle = (start + end) / 2;
            
            // وطبعا هنا هنعمل 
            // recursion
            // علي النص اليمين مرة والنص الشمال مرة لحد ما نوصل ل ليستة من عنصرين
            merge_sort(arr,start,middle);
            merge_sort(arr,middle+1,end);
            
            //هنا بعد اما يخلص تقسيم ويوصل ل ليستة من عنصرين ويبدا يرتبهم باستخدام الدالة دي
            // هنا بنديها بداية ونص ونهاية الجزء الي هيترتب
            merge(arr,start,middle,end);
        }
        
        
    }
    
    private static void merge(int[] arr,int start,int middle,int end){
        
        //هنا بنعمل ليستتيت واحدة للشمال وواحدة لليمين
        //نحط في كل واحدة العناصر الشمال واليمين الي هتترتب
        //هنا بنحسب طول الليستتين
        int left_length = (middle - start) + 1;
        int right_length = end - middle;
        
        //هنا هتعرف الليستتين وتديهم طولهم
        int[] left = new int[left_length];
        int[] right = new int [right_length]; 
        
        //هنا هنحط العناصر الي في النص الشمال
        // عشان نبدا نرتب
        for(int i = 0; i < left.length;i++){
            left[i] = arr[start+i];
        }
        
        //هنا هنحط العناصر الي في النص اليمين
        for(int i = 0; i < right.length;i++){
            right[i] = arr[middle + 1 + i];
        }
        
        //هنا بنعرف متغير ل الليستة الشمال عشان يعدي علي كل عناصرها
        int i = 0;
        //هنا بنعرف متغير ل الليستة اليمين عشان يعدي علي كل عناصرها
        int j = 0;
        //هنا بنعرف متغير ل الليستة الكبيرة
        //وبنقوله ان ترتيب العناصر هيبدا من المكان ده
        int k = start;
        
        //هنا بقي الترتيب بنفضل نمشي لحد اما ليستة من اليمين او الشمال خلاص خلصت واترتبت
        while(i < left.length && j < right.length){
            //هنا مقارنة عادي بين العنصر الي عليه الدور
            
            //هنا لو العنصر الي عليه الدور من الليستة اليمين اكبر من الي عليه الدور في الشمال
            if(left[i] < right[j]){
                
                //بنخلي الي عليه الدور من الليستة الكبيرة الي بنرتب فيها يساوي العنصر الي عليه الدور في الشمال
               arr[k] = left[i]; 
               
               // وبنخليه يشاور علي العنصر الي عليه الدور بعد كده عشان نقارن بيه
               i++;
            }
            
            //ولو العنصر الي علي اليمين اصغر بياخد الي عليه الدور من الليستة الي علي اليمين
            else{
                arr[k] = right[j];
                j++;
            }
            
            //بعد اما ياخد العنصر الاصغر ايا كان بتخليه يشاور علي العنصر الي عليه الدور من الليستة الكبيرة عشان يرتبه هو كمان
            k++;
        }
        
        //هنا لو الليستة اليمين خلصت وباقثي عناصر في الليستة الشمال بنفضيها لانها بتكون مترتبة
        // لو مش واخد بالك بسبب ال 
        // recursion
        // بيكون اليمين والشمال مترتبين 
        // انت هنا الي بتعمله بترتب بين اليستتين المترتبين
        //مهو خلي بالك هما مترتبين اه بس احنا بندمج بينهم عشان كل واحد مرتب عناصره بس ممكن يبقي في هنا عناصر اكبر واصغر وغيره
        while(i < left.length){
            arr[k] = left[i];
            i++;
            k++;
        }
        
        //وهنا نفس الشئ لو اليمين فيه عناصر لسا
         while(j < right.length){
            arr[k] = right[j];
            j++;
            k++;
        }
    }
    
}
